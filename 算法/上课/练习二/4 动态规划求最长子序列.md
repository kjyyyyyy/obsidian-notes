### **第四题：动态规划——最长递增子序列（LIS）**

#### **题型套路总结**  
1. **动态规划核心模板**  
   - **状态定义**：`dp[i]` 表示以 `nums[i]` 结尾的最长递增子序列长度。  
   - **状态转移方程**：  
     $$
     dp[i] = \max_{j < i \text{ 且 } nums[j] < nums[i]} (dp[j] + 1)
     $$  
   - **初始化**：所有 `dp[i]` 初始值为 1（每个元素自身构成长度为 1 的子序列）。  
   - **最终结果**：`dp` 数组中的最大值。  

2. **关键特性**  
   - **时间复杂度**：`O(n²)`，适用于中等规模数据（如 `n ≤ 1000`）。  
   - **空间复杂度**：`O(n)`，需维护 `dp` 数组。  

---

#### **C++ 实现**
```cpp
#include <vector>
#include <algorithm>
using namespace std;

int lengthOfLIS(vector<int>& nums) {
    int n = nums.size();
    if (n == 0) return 0;
    
    vector<int> dp(n, 1); // 初始化 dp 数组
    for (int i = 1; i < n; ++i) { // 遍历每个元素
        for (int j = 0; j < i; ++j) { // 检查前面所有元素
            if (nums[i] > nums[j]) { // 满足递增条件
                dp[i] = max(dp[i], dp[j] + 1); // 状态转移
            }
        }
    }
    return *max_element(dp.begin(), dp.end()); // 返回 dp 中的最大值
}
```

#### **伪代码**
```
function LENGTH-OF-LIS(nums):
    n = len(nums)
    if n == 0:
        return 0
    dp = [1] * n
    for i from 1 to n-1:
        for j from 0 to i-1:
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)
```

---

#### **关键代码点**  
1. **状态初始化**：`vector<int> dp(n, 1)` → 每个元素初始化为 1。  
2. **双重循环**：外层遍历每个元素 `i`，内层遍历所有 `j < i`。  
3. **状态转移**：当 `nums[i] > nums[j]` 时，更新 `dp[i] = max(dp[i], dp[j] + 1)`。  
4. **最终结果**：调用 `*max_element(dp.begin(), dp.end())` 获取最大值。  

---

#### **正确性分析**  
1. **动态规划的最优子结构**  
   - 对于任意位置 `i`，最长递增子序列的长度取决于前面所有比 `nums[i]` 小的元素 `nums[j]` 的最长子序列长度。  
   - 例如：`nums = [10,9,2,5,3,7]`，`dp[5]`（对应 `7`）的值由 `dp[2]`（2）、`dp[3]`（5）、`dp[4]`（3）决定。  

2. **覆盖所有可能情况**  
   - 通过遍历所有 `j < i`，确保所有可能的递增子序列都被考虑。  

---

#### **常见错误与避坑**  
- **错误1：状态转移条件写错**  
  - 若误写为 `nums[i] >= nums[j]`，会导致非严格递增序列被错误统计。  
  - **解决**：严格判断 `nums[i] > nums[j]`。  

- **错误2：忽略空数组检查**  
  - 若输入为空数组，直接访问 `dp[0]` 会导致崩溃。  
  - **解决**：添加 `if (n == 0) return 0`。  

- **错误3：未初始化 `dp` 数组**  
  - 若 `dp` 未初始化为全 1，可能导致结果错误。  
  - **解决**：`vector<int> dp(n, 1)`。  

---

#### **模拟示例**  
**输入**：`nums = [10,9,2,5,3,7,101,18]`  
1. 初始化 `dp = [1,1,1,1,1,1,1,1]`  
2. 遍历 `i=1`（`nums[1]=9`）时，比较 `j=0`（`10`），不满足 `9>10`，`dp[1]` 保持 1。  
3. 遍历 `i=2`（`2`）时，所有 `j < 2` 的 `nums[j]` 均大于 2，`dp[2]` 保持 1。  
4. 遍历 `i=3`（`5`）时，找到 `j=2`（`2`），更新 `dp[3] = dp[2]+1 = 2`。  
5. 最终 `dp = [1,1,1,2,2,3,4,4]`，最大值为 4。  

---

#### **举一反三**  
- **同类问题**：最长公共子序列（LCS）、最大子数组和（Kadane算法）。  
- **变体套路**：  
  - 若要求输出具体子序列，需额外记录路径（如前驱索引）。  
  - 若需优化时间复杂度至 `O(n log n)`，可使用贪心+二分法（见 LeetCode 300 题）。  

**记住口诀**：  
**“动态规划状态定，转移方程靠递增；双重循环填数组，最长子序最大值。”**