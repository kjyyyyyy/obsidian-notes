![[Pasted image 20250520142119.png]]### ==**第一题：分治法寻找绝对众数 ==

#### **题型套路总结**
1. **分治法核心模板**  
   - **分割**：将问题拆成两个子问题（如左右数组）  
   - **递归解决**：分别解决子问题（如递归找左右众数）  
   - **合并**：比较子问题结果，结合全局信息（如统计候选众数的全局次数）  

2. **多数问题的分治特性**  
   - 若存在绝对众数（出现次数 >n/2），则它**必定是左子数组或右子数组的候选众数**。  
   - 合并时只需比较左右候选的全局出现次数，无需遍历整个数组找新候选。

3. **递归终止条件**  
   - 子数组长度为1时，唯一元素即为候选。

4. **关键剪枝逻辑**  
   - 合并时若左右候选相同，直接返回该候选（无需统计次数）。  
   - 若不同，则统计两者在当前数组中的出现次数，选择次数多的候选。

5. **全局验证**  
   - 最终候选需再次验证是否满足绝对众数条件（`count > n/2`），避免误判。

---

#### **代码记忆技巧**
1. **递归框架**  
   ```python
   def majority_element(nums):
       def helper(left, right):
           if left == right:  # 终止条件：单元素子数组
               return nums[left]
           mid = (left + right) // 2
           left_maj = helper(left, mid)  # 左半候选
           right_maj = helper(mid+1, right)  # 右半候选
           if left_maj == right_maj:  # 优化：候选相同直接返回
               return left_maj
           # 统计候选在当前子数组中的次数
           count_left = sum(1 for i in range(left, right+1) if nums[i] == left_maj)
           count_right = sum(1 for i in range(left, right+1) if nums[i] == right_maj)
           return left_maj if count_left > count_right else right_maj
       candidate = helper(0, len(nums)-1)
       return candidate if nums.count(candidate) > len(nums)//2 else -1
   ```

2. **关键代码点**  
   - **递归参数**：始终用 `left` 和 `right` 控制子数组范围。  
   - **合并逻辑**：优先比较候选是否相同，减少不必要的次数统计。  
   - **次数统计**：必须遍历当前子数组（`left` 到 `right`）统计真实次数。  
   - **全局验证**：最终调用 `nums.count(candidate)` 确保结果正确。

---

#### **常见错误与避坑**
- **错误1：忽略全局验证**  
  若直接返回候选，可能返回一个不满足 `>n/2` 的候选（如 `[1,2,3]` 中返回 3）。  
  **解决**：递归返回的候选需二次验证。

- **错误2：次数统计范围错误**  
  统计候选次数时，范围必须是当前子数组（`left` 到 `right`），而非整个数组。  
  **解决**：在 `helper` 函数中传入子数组范围。

- **错误3：递归终止条件写错**  
  若写成 `left >= right` 或 `nums[mid]`，会导致死循环或错误分割。  
  **解决**：严格判断 `left == right`。

- **错误4：时间复杂度超限**  
  频繁调用 `nums.count()` 会导致时间复杂度退化为 O(n²)。  
  **解决**：在合并阶段仅统计当前子数组的次数，而非全局。

---

#### **模拟示例**
以 `nums = [2,2,1,2]` 为例：  
1. **分割**：拆分为 `[2,2]` 和 `[1,2]`。  
2. **递归左半**：`[2,2]` 返回 2。  
3. **递归右半**：`[1,2]` 递归拆分，最终合并时比较 1 和 2 的次数（1 次 vs 1 次），返回 1。  
4. **合并左右候选**：比较 2（3次）和 1（1次），返回 2。  
5. **全局验证**：2 的总次数为 3，`3 > 4/2`，返回 2。

---

#### **举一反三**
- **同类问题**：寻找多数元素（LeetCode 169）、快速选择算法。  
- **变体套路**：  
  - 若问题要求众数出现次数 ≥k，分治合并时需调整统计条件。  
  - 若数组允许不存在绝对众数，需强制验证最终候选。

**记住口诀**：  
**“分治拆，递归找，合并比，全局验。”**



### ==**分治法通用模板（以寻找绝对众数为例）**==

#### **一、分治法通用框架**
```python
def divide_and_conquer问题名称(输入参数):
    def helper(左边界, 右边界):
        # 1. 终止条件：当子数组长度为1时，直接返回唯一元素
        if 左边界 == 右边界:
            return nums[左边界]
        
        # 2. 分割：将数组分为左右两半
        mid = (左边界 + 右边界) // 2
        left_result = helper(左边界, mid)   # 解决左半部分
        right_result = helper(mid+1, 右边界) # 解决右半部分
        
        # 3. 合并：根据左右结果，计算当前区间的最终结果
        return merge(left_result, right_result, 左边界, 右边界)
    
    # 调用递归函数并返回最终结果
    candidate = helper(0, len(nums)-1)
    return candidate if 验证(candidate) else -1
```

---

#### **二、第一题分治法模板（寻找绝对众数）**
```python
def majority_element(nums):
    def helper(left, right):
        # 1. 递归终止条件：子数组长度为1
        if left == right:
            return nums[left]
        
        # 2. 分割：将数组分为左右两半
        mid = (left + right) // 2
        left_maj = helper(left, mid)   # 递归找左半候选众数
        right_maj = helper(mid+1, right) # 递归找右半候选众数
        
        # 3. 合并：比较左右候选众数在整个数组中的出现次数
        if left_maj == right_maj:
            return left_maj  # 优化：候选相同直接返回
        
        # 统计左右候选在当前区间 [left, right] 中的出现次数
        count_left = sum(1 for i in range(left, right+1) if nums[i] == left_maj)
        count_right = sum(1 for i in range(left, right+1) if nums[i] == right_maj)
        
        # 返回出现次数更多的候选
        return left_maj if count_left > count_right else right_maj
    
    # 递归调用并获取候选众数
    candidate = helper(0, len(nums)-1)
    
    # 全局验证候选是否为绝对众数
    return candidate if nums.count(candidate) > len(nums)//2 else -1
```

---

#### **三、模板关键点解析**
| 模板部分       | 作用                                                                 | 本题具体实现                                                                 |
|----------------|----------------------------------------------------------------------|------------------------------------------------------------------------------|
| **递归终止条件** | 控制最小问题规模（如单元素数组）                                       | `left == right` 时返回 `nums[left]`                                         |
| **分割**        | 将原问题拆分为子问题（如左右数组）                                     | `mid = (left + right)//2`，递归处理左右子数组                                |
| **合并逻辑**    | 根据子问题结果，结合当前区间信息生成最终解                             | 比较左右候选的全局次数，选择出现次数更多的候选                               |
| **全局验证**    | 确保递归返回的候选满足最终条件（如绝对众数）                           | 检查候选是否在整体数组中出现次数 > `n/2`                                     |
| **时间复杂度**  | 分治法通常为 `O(n log n)`                                             | 每层递归总复杂度为 `O(n)`，递归深度 `log n` → 总复杂度 `O(n log n)`          |

---

#### **四、正确性分析**
1. **分治策略的正确性**  
   - 若存在绝对众数，则它**必定是左子数组或右子数组的候选众数**。  
   - 合并时通过统计全局次数，确保最终候选为真实绝对众数。

2. **递归终止条件合理性**  
   - 当子数组长度为1时，唯一元素即为候选，无需进一步分割。

3. **合并阶段剪枝逻辑**  
   - 若左右候选相同，直接返回该候选（无需额外统计次数）。  
   - 若不同，则统计两者在当前区间内的全局次数，选择次数更多者。

---

#### **五、举一反三**
- **同类问题**：快速排序、归并排序、寻找最大子数组和。  
- **变体套路**：  
  - 若问题要求众数出现次数 ≥k，调整全局验证条件。  
  - 若数组可能不存在绝对众数，需强制验证最终候选。  

**记住口诀**：  
**“分治拆，递归找，合并比，全局验。”**