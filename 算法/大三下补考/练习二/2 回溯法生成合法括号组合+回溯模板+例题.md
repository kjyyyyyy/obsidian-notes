![[Pasted image 20250520142153.png]]
### 第二题：回溯法生成合法括号组合  
#### **题型套路总结**  
1. **回溯法核心模板**  
   - **选择路径**：每一步可选添加左括号 `(` 或右括号 `)`  
   - **约束条件**：  
     - 左括号数 ≤ `n`（不能超限）  
     - 右括号数 ≤ 左括号数（不能非法闭合）  
   - **终止条件**：字符串长度达到 `2n`  

2. **剪枝逻辑**  
   - 仅当左括号未达上限时添加 `(`  
   - 仅当右括号数小于左括号数时添加 `)`  

3. **递归框架**  
   - 参数设计：当前字符串 `s`、左括号数 `left`、右括号数 `right`  
   - 递归终止：`len(s) == 2n` 时保存结果  
   - 递归分支：按约束条件生成新路径  

---

#### **代码记忆技巧**  
1. **代码框架**  
   ```python
   def generateParenthesis(n):
       res = []
       def backtrack(s, left, right):
           if len(s) == 2 * n:  # 终止条件
               res.append(s)
               return
           if left < n:  # 剪枝：添加左括号
               backtrack(s + '(', left + 1, right)
           if right < left:  # 剪枝：添加右括号
               backtrack(s + ')', left, right + 1)
       backtrack("", 0, 0)
       return res
   ```

2. **关键代码点**  
   - **递归参数**：始终跟踪当前左括号数 `left` 和右括号数 `right`  
   - **剪枝条件**：  
     - `left < n` → 只有左括号未满才能加 `(`  
     - `right < left` → 只有右括号数少于左括号时才能加 `)`  
   - **递归顺序**：先尝试加左括号，再尝试加右括号（保证字典序优先）  

---

#### **常见错误与避坑**  
- **错误1：忘记递归终止条件**  
  若未判断 `len(s) == 2n`，会导致无限递归或结果不完整。  
  **解决**：在函数开头立即判断终止条件。

- **错误2：参数传递错误**  
  递归调用时 `left+1` 和 `right` 必须作为新参数传入，而非修改原变量。  
  **解决**：保持参数不可变性（函数式思维）。

- **错误3：剪枝条件写反**  
  若误写为 `right > left`，会导致非法括号组合（如 `())(`）。  
  **解决**：牢记右括号必须 ≤ 左括号数。

- **错误4：结果未初始化**  
  若 `res` 未定义为列表或未在递归中修改，会导致结果丢失。  
  **解决**：用 `nonlocal` 或类变量传递结果（Python需注意作用域）。

---

#### **模拟示例**  
以 `n=2` 为例，递归过程如下：  
```
初始调用 backtrack("", 0, 0)  
→ left=0 < 2 → 加 '(' → backtrack("(", 1, 0)  
  → left=1 < 2 → 加 '(' → backtrack("((", 2, 0)  
    → left=2 == 2 → 尝试加 ')'（right=0 < left=2）  
      → backtrack("(()", 2, 1)  
        → right=1 < left=2 → 加 ')' → backtrack("(())", 2, 2) ✅  
  → 回溯到 backtrack("(", 1, 0)  
    → right=0 < left=1 → 加 ')' → backtrack("()", 1, 1)  
      → left=1 < 2 → 加 '(' → backtrack("()(", 2, 1)  
        → right=1 < left=2 → 加 ')' → backtrack("()()", 2, 2) ✅  
```
最终结果：`["(())", "()()"]`

---

#### **举一反三**  
- **同类问题**：全排列（LeetCode 46）、组合总和（LeetCode 39）  
- **变体套路**：  
  - 若要求输出非法括号组合 → 移除剪枝条件  
  - 若要求按特定顺序输出 → 调整递归分支顺序（如先加右括号）  

**记住口诀**：  
**“路径选择加剪枝，约束终止要清晰。”**



-------------------------------------------------------------------------
### ==回溯法的核心套路==  
回溯法的本质是**递归穷举所有可能解**，通过**约束条件和剪枝逻辑**提前终止无效路径。其核心框架如下：

---

#### **1. 回溯法通用模板**  
```python
def backtrack(路径, 选择列表, 约束条件):
    if 满足终止条件:
        将路径加入结果集
        return
    for 选择 in 选择列表:
        if 满足约束条件:
            做选择（将当前选择加入路径）
            递归调用 backtrack(...)
            撤销选择（回溯到选择前的状态）
```

---

#### **2. 关键要素**  
| 概念         | 作用                                                                 | 示例（括号生成问题）                     |
|--------------|----------------------------------------------------------------------|------------------------------------------|
| **选择路径** | 记录当前已做出的选择（如已生成的括号字符串）                         | `s = "(()"`                              |
| **选择列表** | 当前可选的决策（如添加左括号或右括号）                               | `choices = ['(', ')']`                   |
| **约束条件** | 限制当前选择的合法性（如左括号不能超过 `n`，右括号不能多于左括号）   | `if left < n: 添加 '('`<br>`if right < left: 添加 ')'` |
| **剪枝逻辑** | 提前终止无效路径（如非法括号组合）                                   | 当右括号数 ≥ 左括号数时，直接跳过右括号  |
| **终止条件** | 判断是否到达解的终点（如字符串长度达到 `2n`）                        | `if len(s) == 2*n: 将 s 加入结果列表`     |

---

#### **3. 约束与剪枝的区别**  
| **约束条件**                          | **剪枝逻辑**                              |
|---------------------------------------|-------------------------------------------|
| 是**选择的前提条件**，决定哪些选择合法 | 是**优化手段**，提前终止无效路径          |
| 必须满足才能继续递归                  | 可选，但能大幅提升效率                    |
| 示例：左括号数 ≤ `n`                  | 示例：右括号数 ≥ 左括号数时直接返回       |

---

#### **4. 典型问题套路总结**  
| 问题类型       | 约束条件                                 | 剪枝逻辑                         | 终止条件               |
|----------------|------------------------------------------|----------------------------------|------------------------|
| **括号生成**   | 左括号数 ≤ `n`，右括号数 ≤ 左括号数      | 右括号数 ≥ 左括号数时剪枝        | 字符串长度达到 `2n`    |
| **全排列**     | 选择的元素未被使用过                     | 已选元素跳过                     | 路径长度等于数组长度   |
| **组合总和**   | 元素可重复选择，总和不超过目标值         | 当前总和超过目标值时剪枝         | 总和等于目标值         |
| **数独求解**   | 行/列/宫格内无重复数字                   | 当前数字在行/列/宫格已存在时剪枝 | 所有空格填满           |

---

#### **5. 常见错误与避坑**  
- **错误1：忘记撤销选择**  
  - **后果**：路径状态错误，导致后续递归结果混乱。  
  - **解决**：递归后必须恢复状态（如 `path.pop()` 或 `board[i][j] = '.'`）。

- **错误2：剪枝条件写反**  
  - **后果**：非法解被保留，合法解被误删。  
  - **解决**：严格验证约束条件（如右括号数必须始终 ≤ 左括号数）。

- **错误3：参数传递错误**  
  - **后果**：递归深度错误或状态丢失。  
  - **解决**：保持参数不可变性（如 `backtrack(path + [num])` 而非修改原变量）。

---

#### **6. 举一反三：回溯法变体**  
- **输出所有解**：需遍历所有可能路径（如括号生成、数独）。  
- **仅需一个解**：找到后立即返回（如 `solveSudoku` 中返回 `True`）。  
- **按特定顺序输出**：调整选择列表的顺序（如先尝试大数或小数）。  

---

#### **7. 口诀记忆**  
**“路径选择加约束，剪枝优化提效率；终止条件定终点，回溯恢复旧状态。”**  

通过反复练习典型问题（如括号生成、全排列、组合总和），可以熟练掌握回溯法的套路。







--------------------------------------------------------------------------




### ==回溯法典型例题总结==  
回溯法适用于**组合、排列、子集、棋盘路径等搜索问题**，核心思想是**递归穷举所有可能解，并通过剪枝优化效率**。以下是常见的经典例题及解题套路：

---

#### **1. 全排列（Permutations）**  
**题目**：给定一个不含重复数字的数组 `nums`，返回其所有可能的全排列。  
**示例**：`nums = [1,2,3]` → `[[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]`  

##### **解题套路**  
- **选择路径**：已选的数字（如 `[1,2]`）  
- **选择列表**：未被选的数字（如 `[3]`）  
- **约束条件**：每个数字只能选一次  
- **剪枝逻辑**：跳过已选的数字  
- **终止条件**：路径长度等于 `len(nums)`  

```python
def permute(nums):
    res = []
    def backtrack(path, candidates):
        if not candidates:  # 终止条件
            res.append(path)
            return
        for i in range(len(candidates)):
            # 剪枝：选择未被选过的数字
            if candidates[i] not in path:
                backtrack(path + [candidates[i]], candidates[:i] + candidates[i+1:])
    backtrack([], nums)
    return res
```

---

#### **2. 组合总和（Combination Sum）**  
**题目**：给定一个候选数字集合 `candidates`（无重复数字）和一个目标值 `target`，返回所有使得数字和为 `target` 的组合（数字可重复使用）。  
**示例**：`candidates = [2,3,6,7], target = 7` → `[[2,2,3], [7]]`  

##### **解题套路**  
- **选择路径**：当前已选的数字（如 `[2,2]`）  
- **选择列表**：当前可选的数字（从当前索引开始）  
- **约束条件**：数字可重复使用，但总和不能超过 `target`  
- **剪枝逻辑**：若当前数字加入后总和超过 `target`，直接跳过  
- **终止条件**：路径总和等于 `target`  

```python
def combinationSum(candidates, target):
    res = []
    def backtrack(start, path, total):
        if total == target:  # 终止条件
            res.append(path)
            return
        if total > target:  # 剪枝
            return
        for i in range(start, len(candidates)):
            # 选择当前数字，允许重复使用（i 不加1）
            backtrack(i, path + [candidates[i]], total + candidates[i])
    backtrack(0, [], 0)
    return res
```

---

#### **3. 子集（Subsets）**  
**题目**：给定一个不含重复数字的数组 `nums`，返回其所有子集（幂集）。  
**示例**：`nums = [1,2,3]` → `[[], [1], [2], [3], [1,2], [1,3], [2,3], [1,2,3]]`  

##### **解题套路**  
- **选择路径**：当前已选的数字（如 `[1]`）  
- **选择列表**：后续未被选的数字（如 `[2,3]`）  
- **约束条件**：每个数字只能选一次  
- **剪枝逻辑**：无需剪枝（所有路径都合法）  
- **终止条件**：每次进入递归都保存路径  

```python
def subsets(nums):
    res = []
    def backtrack(start, path):
        res.append(path[:])  # 每次递归都保存当前路径
        for i in range(start, len(nums)):
            # 选择当前数字，并递归到下一层
            path.append(nums[i])
            backtrack(i + 1, path)  # 下一层从 i+1 开始
            path.pop()  # 回溯
    backtrack(0, [])
    return res
```

---

#### **4. N皇后问题（N-Queens）**  
**题目**：在 `n×n` 棋盘上放置 `n` 个皇后，使得每行、每列和每条斜线上的皇后互不攻击。返回所有合法解。  
**示例**：`n=4` → `[[".Q..","...Q","Q...","..Q."], ["..Q.","Q...","...Q",".Q.."]]`  

##### **解题套路**  
- **选择路径**：当前各行的皇后位置（如 `[1,3,0,2]` 表示第0行皇后在列1，第1行在列3）  
- **约束条件**：每行、每列、每条斜线只能有一个皇后  
- **剪枝逻辑**：判断当前列和斜线是否已有皇后  
- **终止条件**：路径长度等于 `n`（所有行都放置完毕）  

```python
def solveNQueens(n):
    res = []
    def is_valid(row, col, path):
        for r in range(row):
            # 同列或同斜线（行列差绝对值相等）
            if path[r] == col or abs(path[r] - col) == row - r:
                return False
        return True
    
    def backtrack(row, path):
        if row == n:  # 终止条件
            board = []
            for r in range(n):
                line = ['.'] * n
                line[path[r]] = 'Q'
                board.append(''.join(line))
            res.append(board)
            return
        for col in range(n):
            if is_valid(row, col, path):
                backtrack(row + 1, path + [col])
    
    backtrack(0, [])
    return res
```

---

#### **5. 单词搜索（Word Search）**  
**题目**：在 `m×n` 矩阵中搜索是否存在从起点到终点的路径，路径上的字母按顺序组成单词 `word`。  
**示例**：矩阵 `board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"` → `True`  

##### **解题套路**  
- **选择路径**：已走过的坐标（如 `(0,0) → (0,1)`）  
- **约束条件**：不能越界、不能重复访问同一坐标  
- **剪枝逻辑**：当前字符不匹配时直接返回  
- **终止条件**：路径长度等于 `len(word)`  

```python
def exist(board, word):
    m, n = len(board), len(board[0])
    visited = [[False]*n for _ in range(m)]
    
    def backtrack(i, j, k):
        if k == len(word):  # 终止条件
            return True
        if i < 0 or i >= m or j < 0 or j >= n or visited[i][j] or board[i][j] != word[k]:
            return False  # 剪枝
        visited[i][j] = True
        # 向四个方向递归
        res = (backtrack(i+1, j, k+1) or backtrack(i-1, j, k+1) or 
               backtrack(i, j+1, k+1) or backtrack(i, j-1, k+1))
        visited[i][j] = False  # 回溯
        return res
    
    for i in range(m):
        for j in range(n):
            if board[i][j] == word[0] and backtrack(i, j, 0):
                return True
    return False
```

---

#### **回溯法通用套路总结**  
| **问题类型**       | **选择路径**         | **约束条件**                     | **剪枝逻辑**               | **终止条件**               |  
|--------------------|----------------------|----------------------------------|----------------------------|----------------------------|  
| **全排列**         | 已选数字             | 数字不重复                       | 跳过已选数字               | 路径长度等于 `n`           |  
| **组合总和**       | 当前组合             | 数字可重复，总和 ≤ `target`      | 总和超过 `target` 时剪枝   | 总和等于 `target`          |  
| **子集**           | 当前子集             | 每个元素只能选一次               | 无需剪枝                   | 每次递归都保存路径         |  
| **N皇后**          | 各行皇后的位置       | 行/列/斜线无冲突                 | 判断列和斜线冲突           | 路径长度等于 `n`           |  
| **单词搜索**       | 已走路径的坐标       | 不能越界、不能重复访问           | 当前字符不匹配时剪枝       | 路径长度等于 `len(word)`   |  

---

#### **举一反三**  
- **变体问题**：  
  - 允许重复元素的全排列（需去重剪枝）  
  - 含负数的组合总和（需动态调整剪枝条件）  
  - 多个单词的搜索（如单词搜索 II）  
- **关键技巧**：  
  - **剪枝优化**：提前排除非法路径（如总和超限、冲突检查）。  
  - **状态恢复**：递归后必须撤销选择（如 `path.pop()` 或 `visited[i][j] = False`）。  

**记住口诀**：  
**“路径选择加剪枝，约束终止要清晰；回溯恢复旧状态，穷举所有可能性。”**